<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Ph&#x1b0;&#x1a1;ng ph&aacute;p Monte Carlo trong Reinforcement Learning &lpar;H&#x1ecd;c t&abreve;ng c&#x1b0;&#x1edd;ng&rpar;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <p>Tuyệt vời! Mình sẽ chuẩn bị một bài viết bằng tiếng Việt giải thích chi tiết về phương pháp Monte Carlo trong Reinforcement Learning, dựa trên các tài liệu gốc như <em>Reinforcement Learning: An Introduction</em> (Sutton &amp; Barto), <em>Mathematical Foundations of Reinforcement Learning</em> (Shiyu Zhao), và các nguồn đáng tin cậy khác. Bài viết sẽ bao gồm mô tả lý thuyết, các giả định, cách hoạt động, và ví dụ minh hoạ để giúp bạn hiểu rõ cách áp dụng phương pháp này.</p>
<p>Mình sẽ gửi lại cho bạn sớm nhé!</p>
<h1 id="phương-pháp-monte-carlo-trong-reinforcement-learning-học-tăng-cường">Phương pháp Monte Carlo trong Reinforcement Learning (Học tăng cường)</h1>
<h2 id="giới-thiệu-khái-quát-về-reinforcement-learning-và-vai-trò-của-phương-pháp-monte-carlo">Giới thiệu khái quát về Reinforcement Learning và vai trò của phương pháp Monte Carlo</h2>
<p><strong>Reinforcement Learning (Học tăng cường)</strong> là lĩnh vực học máy trong đó một <em>tác tử (agent)</em> học cách hành động trong một <em>môi trường (environment)</em> bằng cách tương tác thử nghiệm và nhận <em>phần thưởng (reward)</em> phản hồi. Mục tiêu của tác tử là tối ưu hóa tổng phần thưởng nhận được theo thời gian. Bài toán RL thường được mô hình hóa dưới dạng <strong>Markov Decision Process (MDP)</strong> gồm tập trạng thái, tập hành động, hàm phần thưởng và (nếu biết) quy luật chuyển trạng thái. Khác với học có giám sát, tác tử RL không được cung cấp sẵn đầu ra đúng cho mỗi đầu vào mà phải tự khám phá chiến lược thông qua <strong>trải nghiệm (experience)</strong>.</p>
<p>Trong RL, có hai cách tiếp cận chính để tìm chiến lược tối ưu: <strong>phương pháp có mô hình (model-based)</strong> và <strong>phương pháp không mô hình (model-free)</strong>. Phương pháp <strong>Dynamic Programming (Quy hoạch động)</strong> là kiểu model-based truyền thống: tác tử biết trước động lực môi trường (xác suất chuyển trạng thái, hàm thưởng) và sử dụng các công thức Bellman để tính toán giá trị và cải thiện chính sách. Ngược lại, phương pháp <strong>Monte Carlo (MC)</strong> là một trong những kỹ thuật model-free cơ bản: tác tử <strong>không cần kiến thức về mô hình môi trường</strong>, thay vào đó học trực tiếp từ những tập trải nghiệm thu được khi tương tác (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=First%20learning%20method%20for%20estimating,we%20learn%20only%20by%20experience">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) (<a href="https://page-one.springer.com/pdf/preview/10.1007/978-981-97-3944-8_5#:~:text=based%20on%20the%20system%20model,If%20we%20do%20not%20have"></a>). Monte Carlo tận dụng việc <strong>lấy mẫu ngẫu nhiên</strong> thông qua các <em>tập</em> (episodes) tương tác để ước lượng giá trị kỳ vọng của các trạng thái hoặc hành động. Nói cách khác, thay vì tính toán giá trị trạng thái dựa trên mô hình toán học, MC <strong>ước lượng giá trị bằng cách trung bình hóa các phần thưởng nhận được</strong> qua nhiều lần thử (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=Monte%20Carlo%20methods%20are%20based,step%20sense">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Phương pháp Monte Carlo giữ vai trò quan trọng trong RL: nó là kỹ thuật đầu tiên giúp <em>ước lượng hàm giá trị</em> và <em>tìm kiếm chính sách tối ưu</em> chỉ từ dữ liệu trải nghiệm, mở đường cho các thuật toán học tăng cường hiện đại mà không đòi hỏi hiểu biết tường minh về môi trường (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=First%20learning%20method%20for%20estimating,we%20learn%20only%20by%20experience">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>).</p>
<p>Tổng quan, Monte Carlo trong RL dùng để <strong>dự đoán giá trị (value prediction)</strong> cho một chính sách nhất định và <strong>điều khiển (control)</strong> để cải thiện chính sách, thông qua việc chạy mô phỏng nhiều lần. Phần sau sẽ đi sâu vào nguyên lý hoạt động của phương pháp này, các biến thể on-policy/off-policy, so sánh với Dynamic Programming, điều kiện áp dụng, hạn chế và một ví dụ minh họa chi tiết.</p>
<h2 id="lý-thuyết-của-phương-pháp-monte-carlo-nguyên-lý-học-từ-trải-nghiệm-và-cập-nhật-giá-trị">Lý thuyết của phương pháp Monte Carlo: Nguyên lý học từ trải nghiệm và cập nhật giá trị</h2>
<p>Phương pháp Monte Carlo trong RL học thông qua <strong>trải nghiệm đầy đủ các tập tương tác</strong>. Mỗi tập bắt đầu từ một trạng thái xuất phát và tiếp diễn cho đến khi kết thúc (một trạng thái kết thúc hoặc sau một số bước cố định). Trong quá trình đó, tác tử theo một chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> nhất định, tạo ra một chuỗi trạng thái, hành động và phần thưởng: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>S</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">S_0, A_0, R_1, S_1, A_1, R_2, \dots, S_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (trong đó <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">S_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> là trạng thái kết thúc của tập và không có hành động tiếp theo). <strong>Tổng phần thưởng tích lũy</strong> từ thời điểm <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> (gọi là <em>return</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">G_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) được định nghĩa là:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub><mo>=</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>R</mi><mi>T</mi></msub><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">G_t = R_{t+1} + R_{t+2} + \dots + R_T,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p>
<p>(có thể bao gồm hệ số chiết khấu nếu xét bài toán dài hạn, nhưng ở đây giả sử phần thưởng không chiết khấu để đơn giản). Mục tiêu của MC là ước lượng <strong>hàm giá trị</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mi>π</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V^{\pi}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> = kỳ vọng của <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">G_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> khi bắt đầu từ trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> và theo chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. Do không biết trước kỳ vọng này, ta <strong>lấy mẫu nhiều lần</strong> và sử dụng <strong>trung bình mẫu</strong> để xấp xỉ nó (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=Monte%20Carlo%20methods%20are%20based,step%20sense">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>).</p>
<p><strong>Nguyên lý hoạt động:</strong> Monte Carlo lưu lại các kết quả nhận được sau mỗi tập và dần dần cập nhật giá trị trạng thái dựa trên trung bình các phần thưởng thu được. Cụ thể, giả sử ta muốn ước lượng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>π</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v_{\pi}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> cho một trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> dưới chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. Ta cho tác tử <strong>chơi nhiều tập</strong> theo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. Mỗi khi trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> xuất hiện trong một tập, ta ghi nhận <em>return</em> thực tế <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> thu được kể từ lần xuất hiện đó cho đến cuối tập. Sau nhiều tập, ta sẽ có một tập hợp các giá trị <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> thu được khi bắt đầu từ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>. <strong>Giá trị của trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></strong> được ước lượng bằng <strong>trung bình các giá trị <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> này</strong>:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>≈</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mi>N</mi></mfrac></mstyle><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">V(s) \approx \dfrac{1}{N} \sum_{i=1}^{N} G^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>,</li>
</ul>
<p>với <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">G^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> là tổng thưởng thu được từ trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> trong tập thứ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> mà <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> xuất hiện. Khi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> tiến đến vô hạn (tức số tập rất lớn), luật số lớn chỉ ra rằng giá trị trung bình mẫu sẽ hội tụ về đúng kỳ vọng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>π</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v_{\pi}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=An%20obvious%20way%20to%20estimate,converge%20to%20the%20expected%20value">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>).</p>
<p><strong>First-visit MC và Every-visit MC:</strong> Có hai cách cập nhật phổ biến: <em>first-visit</em> và <em>every-visit</em>. <em>First-visit MC</em> cập nhật giá trị trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> <strong>chỉ dùng lần đầu tiên <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> được ghé thăm trong mỗi tập</strong> (bỏ qua các lần ghé thăm sau trong cùng tập), trong khi <em>Every-visit MC</em> cập nhật dựa trên <strong>tất cả các lần</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> xuất hiện (trung bình tất cả returns sau mọi lần ghé thăm) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=,after%20each%20visit%20to%20%24s">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Cả hai cách tiếp cận đều đảm bảo hội tụ về giá trị thật khi số tập tăng lên đủ lớn, nhưng first-visit MC thường được dùng nhiều vì đơn giản và mỗi tập đóng góp một giá trị cho mỗi trạng thái thay vì nhiều lần.</p>
<p><strong>Cập nhật giá trị và học từ trải nghiệm:</strong> Thuật toán MC cơ bản cho dự đoán giá trị sẽ như sau (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=%21%20Idea%3A%20Average%20returns%20observed,episode%20%21%20Both%20converge%20asymptotically">Chapter 5.ppt</a>) (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=%21%20First,episode%20%21%20Both%20converge%20asymptotically">Chapter 5.ppt</a>):</p>
<ol>
<li>Khởi tạo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> ngẫu nhiên cho mọi trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>.</li>
<li>Thực hiện nhiều tập tương tác dưới chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</li>
<li>Với mỗi trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> xuất hiện trong tập, tính <em>return</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> kể từ lần xuất hiện (đầu tiên) đó. Thêm <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> vào danh sách các returns của trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>.</li>
<li>Cập nhật <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> = trung bình của tất cả các returns thu thập được trong danh sách. (Hoặc cập nhật tăng dần <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>←</mo><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo stretchy="false">[</mo><mi>G</mi><mo>−</mo><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V(s) \leftarrow V(s) + \alpha [G - V(s)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)]</span></span></span></span> với <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> là tốc độ học, tương đương với tính trung bình cộng dồn).</li>
<li>Lặp lại đến khi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> hội tụ (không đổi đáng kể giữa các lần cập nhật).</li>
</ol>
<p>Điểm mấu chốt là MC <strong>sử dụng toàn bộ phần thưởng của cả tập</strong> để cập nhật giá trị của các trạng thái trong tập đó. Không giống như Dynamic Programming hay Temporal-Difference (TD) sử dụng phương trình Bellman để cập nhật từng bước dựa trên ước lượng hiện tại, Monte Carlo <strong>không “bootstrapping” từ các giá trị ước lượng hiện có mà dùng trực tiếp kết quả thực tế cuối cùng</strong> (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Blackjack%20value%20functions">Chapter 5.ppt</a>) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=We%20can%20apply%20backup%20diagrams,instead%20of%20all%20possible%20transitions">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Mỗi trạng thái được cập nhật hoàn toàn độc lập dựa trên các trải nghiệm chứa nó, không phụ thuộc vào giá trị hiện tại của các trạng thái kế tiếp. Chính vì vậy, MC thuộc loại <strong>phương pháp không bootstrapping</strong>, và được xem là <em>unbiased</em> (không chệch) vì sử dụng giá trị thật (dựa trên mẫu) chứ không dùng ước lượng trung gian. Tuy nhiên, do dựa trên mẫu ngẫu nhiên, ước lượng MC có thể có <strong>phương sai lớn</strong> – cần rất nhiều tập để giá trị trung bình hội tụ ổn định.</p>
<p>Một ưu điểm quan trọng của MC là <strong>dễ hiểu và dễ triển khai</strong>: chỉ cần chạy mô phỏng nhiều lần và trung bình kết quả. Ngoài ra, <strong>thời gian tính toán giá trị cho một trạng thái không phụ thuộc vào số lượng trạng thái toàn cục</strong> (vì ta có thể chỉ tập trung mô phỏng những tập liên quan trạng thái đó) (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Blackjack%20value%20functions">Chapter 5.ppt</a>). Điều này khác với DP khi muốn cập nhật một trạng thái phải xem xét tất cả khả năng chuyển tiếp đến các trạng thái khác theo mô hình. Tuy nhiên, nhược điểm lớn của MC là nó <strong>đòi hỏi các tập phải kết thúc</strong> (episodic) để thu thập phần thưởng cuối cùng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">G_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Ta <strong>phải chờ đến cuối mỗi tập</strong> mới biết được tổng thưởng để cập nhật, nên không thể cập nhật giá trị giữa chừng trong một tập đang diễn ra (<a href="https://users.ece.cmu.edu/~yuejiec/ece18813B_notes/lecture8-model-free-MC-TD.pdf#:~:text=Caveat%20of%20Monte%20Carlo%20methods%3A,11">Foundations of Reinforcement Learning  Model-free RL: Monte Carlo and temporal difference (TD) learning</a>). Điều này khiến MC không áp dụng trực tiếp được cho các tác vụ không có trạng thái kết thúc (tiếp diễn vô hạn) nếu không có cách chia tập nhân tạo. Ngoài ra, số tập cần thiết có thể rất lớn, đặc biệt khi không phải mọi trạng thái đều được ghé thăm thường xuyên – MC yêu cầu chính sách phải <strong>thăm dò đủ</strong> (sẽ nói thêm ở phần sau) để mọi trạng thái/hành động đều có cơ hội nhận thưởng và được cập nhật giá trị.</p>
<p>Tóm lại, lý thuyết Monte Carlo trong RL dựa trên việc <em>học qua trải nghiệm</em>: thu thập nhiều kết quả từ trạng thái/hành động và dùng <strong>trung bình mẫu</strong> để xấp xỉ giá trị kỳ vọng. Nhờ đó, tác tử có thể dần dần xây dựng chính xác hàm giá trị cho chính sách hiện tại chỉ thông qua tương tác thử sai lặp đi lặp lại.</p>
<h2 id="monte-carlo-prediction-và-monte-carlo-control-on-policy-vs-off-policy">Monte Carlo Prediction và Monte Carlo Control (On-policy vs Off-policy)</h2>
<p>Phương pháp Monte Carlo được ứng dụng vào hai nhiệm vụ chính trong RL: <strong>Prediction (dự đoán giá trị)</strong> và <strong>Control (tìm kiếm/chọn lựa chính sách tối ưu)</strong>. Nói một cách đơn giản, <em>prediction</em> là đánh giá “chất lượng” của một chính sách đã cho, còn <em>control</em> là cải thiện chính sách dựa trên các đánh giá đó. Chúng ta sẽ xem cách MC giải quyết từng nhiệm vụ, và phân biệt hai cách tiếp cận: <strong>on-policy</strong> và <strong>off-policy</strong>.</p>
<h3 id="monte-carlo-prediction-ước-lượng-giá-trị-của-chính-sách-cho-trước">Monte Carlo Prediction (Ước lượng giá trị của chính sách cho trước)</h3>
<p>Trong bài toán dự đoán, ta giả sử có một chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> cố định (ví dụ: một bảng xác suất chọn hành động ở mỗi trạng thái). Nhiệm vụ là ước lượng hàm giá trị <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mi>π</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V^{\pi}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> (hoặc <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mi>π</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q^{\pi}(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> nếu xét giá trị hành động) cho <em>mọi trạng thái</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> dưới chính sách đó. <strong>Monte Carlo prediction</strong> thực hiện điều này bằng cách chạy nhiều tập theo chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> và áp dụng nguyên lý như mô tả ở phần trên: <em>giá trị của trạng thái là trung bình các phần thưởng thu được sau những lần trạng thái đó xuất hiện</em> (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=An%20obvious%20way%20to%20estimate,converge%20to%20the%20expected%20value">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). MC prediction không yêu cầu mô hình môi trường, chỉ cần khả năng sinh ra trải nghiệm theo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> (tức là mô phỏng hoặc tương tác thật với môi trường theo chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>).</p>
<p>Để đảm bảo mỗi trạng thái đều được thăm dò đủ, thường ta cần <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> là một <strong>chính sách khám phá</strong>: nghĩa là mọi hành động từ mọi trạng thái đều có xác suất &gt; 0 được thực hiện. Nếu chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> mang tính quyết định cứng nhắc (luôn chọn một hành động duy nhất ở một trạng thái), có thể một số trạng thái/hành động sẽ không bao giờ được trải nghiệm, khiến giá trị của chúng không thể ước lượng chính xác. Một kỹ thuật thường dùng để đảm bảo thăm dò trong prediction là <strong>Exploring Starts</strong> – khi sinh tập mới, ta bắt đầu từ một trạng thái và hành động ngẫu nhiên, qua đó về lâu dài mọi trường hợp đều sẽ xuất hiện (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=Problem%3A%20many%20state,We%20must%20assure%20continual%20exploration">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Ngoài ra, nếu <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> ban đầu không đủ ngẫu nhiên, ta có thể tạm dùng một chính sách khám phá (ví dụ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-greedy) để thu thập dữ liệu cho việc đánh giá <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> – khi đó ta đang làm <em>off-policy prediction</em> (sẽ nói sau). Nhưng trong bối cảnh prediction thuần túy, ta thường giả sử <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> đã bao quát các hành động có thể.</p>
<p>Kết quả của Monte Carlo prediction là một bảng giá trị <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> hoặc <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> xấp xỉ cho chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>. Trong sách của Sutton &amp; Barto, ví dụ <em>đánh giá chính sách chơi Blackjack</em> bằng MC (trình bày ở phần ví dụ) cho thấy phương pháp này hiệu quả như thế nào trong việc ước lượng giá trị kỳ vọng của trạng thái mà không cần bất kỳ kiến thức nào về luật xác suất trong game (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=Example%3A%20Blackjack%20%E2%80%A2%20Goal%3A%20Achieve,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>).</p>
<h3 id="monte-carlo-control-điều-khiển--tìm-chính-sách-tối-ưu">Monte Carlo Control (Điều khiển – tìm chính sách tối ưu)</h3>
<p>Bài toán <em>control</em> khó hơn: thay vì đánh giá một chính sách cố định, ta muốn <strong>tìm ra chính sách tối ưu</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\pi^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> mang lại phần thưởng trung bình cao nhất từ mọi trạng thái. Monte Carlo giải quyết bài toán này bằng cách kết hợp đánh giá (prediction) và cải thiện (improvement) chính sách theo nguyên lý của <strong>Generalized Policy Iteration (GPI)</strong>: lặp đi lặp lại việc ước lượng giá trị dưới chính sách hiện tại và sau đó <strong>cập nhật chính sách tham lam (greedy) theo giá trị đó</strong> (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=This%20section%20is%20about%20how,policy%20and%20optimal%20value%20function">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=Policy%20improvement%20is%20done%20by,value%20function">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Cụ thể, quy trình như sau:</p>
<ul>
<li>Khởi tạo một chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (có thể ngẫu nhiên hoặc tùy ý nhưng phải bảo đảm mọi hành động đều có cơ hội – chi tiết bên dưới).</li>
<li><strong>Chính sách đánh giá (Policy Evaluation):</strong> Sử dụng Monte Carlo prediction để ước lượng hàm giá trị <em>hành động</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><msub><mi>π</mi><mi>k</mi></msub></msup><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q^{\pi_k}(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> cho chính sách hiện tại <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\pi_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. (Lưu ý: trong control, ta thường tập trung ước lượng <strong>giá trị hành động <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></strong> thay vì chỉ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>, vì nếu không có mô hình, việc chọn hành động tốt nhất dựa trên <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> là không trực tiếp – ta cần biết hành động nào dẫn đến trạng thái nào. Với <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>, ta chỉ việc chọn hành động có <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> cao nhất tại mỗi trạng thái (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=If%20the%20model%20of%20a,p%24%20here">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=If%20the%20model%20of%20a,p%24%20here">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>)).</li>
<li><strong>Cải thiện chính sách (Policy Improvement):</strong> Từ hàm <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><msub><mi>π</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">Q^{\pi_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> vừa ước lượng, tạo chính sách mới <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> bằng cách <strong>tham lam với <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span></strong>: tại mỗi trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> chọn hành động <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo>∗</mo></msup><mo>=</mo><mi>arg</mi><mo>⁡</mo><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mi>a</mi></msub><msup><mi>Q</mi><msub><mi>π</mi><mi>k</mi></msub></msup><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^* = \arg\max_a Q^{\pi_k}(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> chính là chính sách tốt hơn hoặc bằng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\pi_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> theo Định lý cải thiện chính sách.</li>
<li>Lặp lại: Đặt <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k := k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> và lặp lại chu kỳ <em>đánh giá bằng MC</em> (với các tập mới theo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\pi_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) rồi <em>cải thiện</em>. Quá trình này tiếp diễn cho đến khi chính sách không thay đổi nữa (đạt tối ưu).</li>
</ul>
<p>Vì Monte Carlo đánh giá chính sách dựa trên mẫu, về mặt lý thuyết ta cần số lượng tập vô hạn ở mỗi bước đánh giá để đạt giá trị chính xác tuyệt đối. Tuy nhiên, tương tự như policy iteration thông thường, trong thực tế ta có thể xen kẽ một cách <em>không tuần tự tuyệt đối</em>: ví dụ <strong>đánh giá xong mỗi tập là cải thiện luôn</strong> một lượt (MC thường làm kiểu này: sau mỗi tập, cập nhật <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> cho các trạng thái-hành động đã thấy và cải thiện chính sách ngay trên những trạng thái đó (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=,1%20in%20value%20iteration">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>)). Điều này tương đương với thực hiện <em>policy iteration không đồng bộ</em>, và về lâu dài vẫn hướng tới tối ưu.</p>
<p><strong>On-policy vs Off-policy trong Monte Carlo Control:</strong> Một thách thức trong MC control là đảm bảo <strong>khám phá đủ</strong>. Nếu ta luôn chọn hành động tham lam theo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> hiện tại, có nguy cơ tác tử bỏ qua những hành động có thể có giá trị cao chưa được thử đến – dẫn đến kết quả chính sách có thể bị kẹt ở mức cục bộ. Để tránh điều này, có hai hướng tiếp cận:</p>
<ul>
<li>
<p><strong>On-policy MC control:</strong> Ta sẽ <em>học và cải thiện <strong>ngay trên chính sách đang được thi hành</strong></em>. Điều này đòi hỏi chính sách luôn phải có tính ngẫu nhiên nhất định để khám phá. Cách làm phổ biến là dùng <strong>chính sách mềm (soft policy)</strong>, ví dụ <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">ϵ</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">ϵ</span></span></span></span></span></span>-greedy</strong>: hầu hết thời gian chọn hành động tham lam, nhưng thỉnh thoảng (với xác suất <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>) chọn ngẫu nhiên một hành động khác (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Blackjack%20example%20continued%20%21%20Exploring,Initial%20policy%20as%20described%20before">Chapter 5.ppt</a>). Nhờ đó, mọi hành động đều có xác suất được chọn khác 0 tại mỗi trạng thái. Thuật toán cụ thể gọi là <strong>On-policy First-Visit MC Control với <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-soft</strong>:</p>
<ol>
<li>Khởi tạo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> tùy ý và chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> là <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-soft (ví dụ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-greedy).</li>
<li>Mỗi tập: thực thi theo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> hiện tại, thu thập phần thưởng và cập nhật <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> cho mọi cặp trạng thái-hành động xuất hiện (theo first-visit MC, trung bình hóa các returns).</li>
<li>Sau tập đó, cải thiện chính sách <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>: tại mỗi trạng thái vừa ghé thăm, chọn hành động có <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> cao nhất làm hành động tham lam, các hành động khác vẫn giữ một xác suất nhỏ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> (đảm bảo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> luôn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-soft) (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Blackjack%20example%20continued%20%21%20Exploring,Initial%20policy%20as%20described%20before">Chapter 5.ppt</a>).</li>
<li>Lặp lại.</li>
</ol>
<p>Với phương pháp on-policy, chính sách <em>vừa học vừa thực thi</em> này sẽ dần dần hội tụ tới <strong>chính sách tối ưu <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-soft</strong> (và khi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> rất nhỏ, chính sách gần tối ưu thuần túy). Sutton &amp; Barto chứng minh rằng nếu mọi cặp <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> tiếp tục được thăm dò, quá trình này sẽ không dừng ở một chính sách kém tối ưu nào – cuối cùng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> và <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> sẽ ổn định khi cả hai đạt tối ưu (vì nếu <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> chưa tối ưu, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> ước lượng sẽ khiến <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> đổi lựa chọn) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=Image%20Fig%205,Exploring%20starts">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>).</p>
</li>
<li>
<p><strong>Off-policy MC control:</strong> Thay vì sử dụng cùng một chính sách để vừa thu thập dữ liệu vừa cải thiện, off-policy tách biệt hai chính sách: <strong>chính sách hành vi (behavior policy)</strong> dùng để sinh trải nghiệm, và <strong>chính sách đích (target policy)</strong> là cái ta thực sự muốn tối ưu hóa (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=%2A%20on,used%20to%20generate%20the%20data">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Trong ngữ cảnh này, chính sách hành vi thường được chọn sao cho <strong>mang tính khám phá cao</strong> (ví dụ chọn hành động ngẫu nhiên hoặc <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-greedy rộng rãi), đảm bảo mọi hành động đều có cơ hội. Chính sách đích thường là <em>tham lam</em> (deterministic) hướng tới tối ưu. Chúng ta sẽ sử dụng dữ liệu do behavior policy sinh ra để ước lượng giá trị cho target policy. Tuy nhiên, do hai chính sách khác nhau, phân phối trạng thái-hành động trong tập mẫu không khớp với phân phối theo target policy, cần một cơ chế hiệu chỉnh. <strong>Importance Sampling (Lấy mẫu quan trọng)</strong> được sử dụng cho mục đích này: mỗi <em>return</em> từ tập thu thập được sẽ được <strong>gán trọng số <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></strong> bằng <strong>tỷ số xác suất</strong> rằng tập đó xảy ra dưới target policy so với dưới behavior policy (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Off,probabilities%20in%20the%20estimation%20policy">Chapter 5.ppt</a>). Ví dụ, nếu một chuỗi hành động <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>T</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_0, a_1, ..., a_{T-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> xảy ra với xác suất <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> theo behavior và xác suất <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">P^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> theo target, thì trọng số <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><msup><mi>P</mi><mo>∗</mo></msup><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\rho = P^*/P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> sẽ được nhân vào phần thưởng của chuỗi đó khi cập nhật cho target. Thực hành phổ biến trong off-policy MC là dùng <strong>weighted importance sampling</strong> (lấy mẫu quan trọng có trọng số) để giữ cho trọng số luôn được chuẩn hóa (tổng trọng số = 1), giúp giảm phương sai so với công thức importance sampling thông thường (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=,and%20thus%20is%20strongly%20preferred">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Kết quả là ta thu được ước lượng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mtext>target</mtext></msup><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q^{\text{target}}(s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">target</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> mặc dù các tập dữ liệu được sinh bởi behavior policy.</p>
<p>Off-policy MC cho phép, chẳng hạn, <strong>học chính sách tối ưu trong khi vẫn áp dụng một chính sách khám phá khác</strong>. Một ứng dụng thực tế là trong môi trường thực tế (như huấn luyện robot), ta muốn thu thập dữ liệu an toàn (behavior policy thiên về khám phá an toàn), đồng thời học về một chính sách tối ưu hơn (target policy) mà không gây rủi ro trong quá trình học. Tuy nhiên, nhược điểm lớn của off-policy MC là trọng số importance sampling có thể dao động rất lớn, dẫn đến <strong>phương sai cao hoặc thậm chí vô hạn</strong> trong ước lượng (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=,and%20thus%20is%20strongly%20preferred">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) nếu chính sách đích quá khác biệt và hiếm khi “giả lập” được bởi chính sách hành vi. Để giảm thiểu, người ta ưu tiên weighted sampling và cũng thường chọn behavior policy đủ “phủ” target policy (ví dụ behavior là <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-soft và giảm dần <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> theo thời gian để dần tiệm cận target).</p>
</li>
</ul>
<p>Tóm lại, <strong>on-policy MC control</strong> học chính sách tối ưu bằng cách liên tục điều chỉnh chính sách đang thực thi (duy trì tính ngẫu nhiên để khám phá), trong khi <strong>off-policy MC control</strong> học chính sách tối ưu gián tiếp từ dữ liệu của một chính sách khác. Cả hai đều hướng đến giải quyết bài toán điều khiển, nhưng on-policy đơn giản hơn (không cần importance sampling) và được dùng nhiều trong thực nghiệm, còn off-policy tổng quát hơn về mặt lý thuyết (cho phép đánh giá bất kỳ chính sách nào từ dữ liệu khác).</p>
<h2 id="so-sánh-monte-carlo-với-dynamic-programming-và-các-phương-pháp-khác">So sánh Monte Carlo với Dynamic Programming (và các phương pháp khác)</h2>
<p>Monte Carlo có những điểm tương đồng và khác biệt quan trọng với phương pháp Dynamic Programming (DP) – vốn cũng nhằm mục tiêu tính giá trị và tìm chính sách tối ưu nhưng yêu cầu mô hình môi trường. Dưới đây là bảng so sánh giữa MC và DP:</p>
<table>
<thead>
<tr>
<th>Khía cạnh</th>
<th><strong>Monte Carlo (MC)</strong></th>
<th><strong>Dynamic Programming (DP)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Kiến thức môi trường</strong></td>
<td><em>Model-free:</em> <strong>Không cần</strong> mô hình xác suất chuyển tiếp hay phần thưởng. Học trực tiếp từ dữ liệu tương tác ([Sutton &amp; Barto summary chap 05 - Monte Carlo methods</td>
<td>lcalem](<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=First%20learning%20method%20for%20estimating,we%20learn%20only%20by%20experience">https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=First learning method for estimating,we learn only by experience</a>)).</td>
</tr>
<tr>
<td><strong>Nguyên lý cập nhật</strong></td>
<td><strong>Lấy mẫu và trung bình:</strong> Sử dụng <em>returns</em> từ các tập thử nghiệm thực tế để cập nhật giá trị. <strong>Không bootstrap</strong> – dùng giá trị phần thưởng thực thu được đến cuối tập ([Sutton &amp; Barto summary chap 05 - Monte Carlo methods</td>
<td>lcalem](<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=We%20can%20apply%20backup%20diagrams,instead%20of%20all%20possible%20transitions">https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=We can apply backup diagrams,instead of all possible transitions</a>)).</td>
</tr>
<tr>
<td><strong>Yêu cầu tập (episode)</strong></td>
<td><strong>Cần tập kết thúc:</strong> Chỉ áp dụng trực tiếp cho bài toán phân đoạn (episodic). Phải đợi tập kết thúc mới cập nhật được giá trị (<a href="https://users.ece.cmu.edu/~yuejiec/ece18813B_notes/lecture8-model-free-MC-TD.pdf#:~:text=Caveat%20of%20Monte%20Carlo%20methods%3A,11">Foundations of Reinforcement Learning  Model-free RL: Monte Carlo and temporal difference (TD) learning</a>). Không hoạt động tốt nếu nhiệm vụ không có trạng thái kết thúc (trừ khi cắt thành tập nhân tạo).</td>
<td><strong>Không cần tập kết thúc:</strong> Có thể áp dụng cho cả bài toán tiếp diễn (infinite-horizon) bằng cách giải phương trình Bellman với hệ số chiết khấu. DP không phụ thuộc vào khái niệm tập trải nghiệm.</td>
</tr>
<tr>
<td><strong>Hiệu quả tính toán</strong></td>
<td><strong>Mẫu độc lập:</strong> Thời gian ước lượng một trạng thái chủ yếu phụ thuộc số lần trạng thái đó được ghé thăm trong mẫu, <strong>không phụ thuộc kích thước không gian trạng thái tổng</strong> (<a href="https://people.cs.umass.edu/barto/courses/cs687/Chapter%205.pdf#:~:text=Blackjack%20value%20functions">Chapter 5.ppt</a>). Thích hợp khi mô phỏng nhanh hoặc số trạng thái lớn (vì không cần duyệt qua toàn bộ trạng thái).</td>
<td><strong>Toàn cục:</strong> Phải tính toán trên <em>toàn bộ không gian trạng thái</em> (ví dụ, cập nhật giá trị từng trạng thái trong mỗi bước lặp). Với không gian trạng thái lớn, DP có thể chậm hoặc không khả thi do chi phí tính toán tăng mạnh theo số trạng thái.</td>
</tr>
<tr>
<td><strong>Độ chính xác và hội tụ</strong></td>
<td><strong>Xấp xỉ, phương sai cao:</strong> Kết quả MC là ước lượng dựa trên mẫu nên có <strong>phương sai</strong>. Cần rất nhiều mẫu để hội tụ về giá trị kỳ vọng thật (<a href="https://users.ece.cmu.edu/~yuejiec/ece18813B_notes/lecture8-model-free-MC-TD.pdf#:~:text=Caveat%20of%20Monte%20Carlo%20methods%3A,11">Foundations of Reinforcement Learning  Model-free RL: Monte Carlo and temporal difference (TD) learning</a>). Khi số tập → ∞ thì <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> hội tụ chính xác (nếu mọi trạng thái được khám phá đủ).</td>
<td><strong>Chính xác (nếu có mô hình):</strong> DP giải đúng hệ phương trình Bellman nên về lý thuyết có thể hội tụ đến giá trị <em>chính xác</em> của hàm giá trị (tất nhiên trong thực tế có thể dừng sau hữu hạn bước với sai số nhỏ). Không có sai số do mẫu, nhưng có thể có sai số do truncation nếu dừng sớm.</td>
</tr>
<tr>
<td><strong>Ưu điểm chính</strong></td>
<td>- <strong>Không cần mô hình</strong>, có thể áp dụng trực tiếp lên môi trường thực hoặc mô phỏng. <br/>- <strong>Dễ hiểu và cài đặt</strong> (chỉ cần thu thập trung bình mẫu). <br/>- Có thể tập trung tính giá trị cho những phần quan trọng của không gian trạng thái (qua trải nghiệm) thay vì duyệt toàn bộ.</td>
<td>- <strong>Tận dụng tri thức môi trường</strong>: cho kết quả chính xác và thường hội tụ nhanh nếu không gian trạng thái nhỏ. <br/>- <strong>Bảo đảm tối ưu toàn cục</strong> khi có mô hình hoàn chỉnh (ví dụ Value Iteration luôn tìm được <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\pi^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> nếu tính toán đủ lâu).</td>
</tr>
<tr>
<td><strong>Nhược điểm chính</strong></td>
<td>- <strong>Đòi hỏi nhiều tập</strong> để đạt kết quả ổn định; hiệu quả kém khi phần thưởng có độ biến động lớn (variance cao). <br/>- <strong>Chỉ áp dụng tự nhiên cho episodic</strong>; đối với continuing tasks cần thủ thuật (ví dụ cắt chuỗi) dễ gây sai số. <br/>- <strong>Không có mô hình</strong> nên không thể suy luận “giả lập” mà phải thử nghiệm thật, có thể tốn kém hoặc nguy hiểm trong môi trường thực.</td>
<td>- <strong>Cần mô hình</strong> – không áp dụng được nếu môi trường phức tạp, không biết xác suất hoặc không thể mô hình hóa. <br/>- <strong>Bùng nổ tính toán</strong> với bài toán lớn (state space, action space lớn) do phải duyệt qua mọi trạng thái, hoặc lưu trữ bảng giá trị khổng lồ. <br/>- Không sử dụng được trực tiếp trong môi trường thực không mô phỏng (vì không thể có mô hình xác suất chính xác).</td>
</tr>
</tbody>
</table>
<p>Ngoài DP, Monte Carlo cũng nên được so sánh với các phương pháp model-free khác, đặc biệt là <strong>Temporal-Difference (TD) Learning</strong>. TD (như SARSA, Q-learning) cũng không cần mô hình nhưng cập nhật giá trị <em>từng bước một</em> dựa trên giá trị ước lượng hiện tại (bootstrapping). So với TD, MC <strong>không bootstrapping</strong> nên không chịu bias do ước lượng tạm thời, nhưng TD có ưu thế <strong>cập nhật liên tục mỗi bước</strong> (không phải chờ hết tập) và thường <strong>hội tụ nhanh hơn với ít phương sai hơn</strong> do sử dụng thêm thông tin cấu trúc Markov. Trong thực tiễn, TD và các biến thể (như <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-step TD, TD(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>)) phổ biến hơn cho các tác vụ dài hạn hoặc khi dữ liệu thu thập online liên tục. Tuy nhiên, Monte Carlo vẫn là phương pháp nền tảng, trực quan và thường hoạt động tốt trong các môi trường mô phỏng với tập tương tác rõ ràng.</p>
<p>Tựu trung, Monte Carlo và Dynamic Programming đại diện cho hai thái cực: một bên dùng mẫu để ước lượng không cần mô hình, một bên dùng mô hình để tính toán chính xác. Lựa chọn phương pháp tùy thuộc vào hoàn cảnh: nếu có mô hình tin cậy và không gian trạng thái nhỏ, DP cho kết quả nhanh và chính xác; nếu mô hình phức tạp hoặc không biết, Monte Carlo là lựa chọn tự nhiên để “học từ trải nghiệm”. Nhiều thuật toán RL hiện đại kết hợp ý tưởng của cả hai (như TD kết hợp mẫu + bootstrapping, hay giả lập môi trường để áp dụng DP cục bộ trong thuật toán Monte Carlo Tree Search, v.v.).</p>
<h2 id="điều-kiện-áp-dụng-và-hạn-chế-của-phương-pháp-monte-carlo">Điều kiện áp dụng và hạn chế của phương pháp Monte Carlo</h2>
<p>Như đã đề cập, phương pháp Monte Carlo <strong>thích hợp nhất cho các bài toán có tập tương tác ngắt quãng (episodic)</strong> – mỗi tập phải có điểm dừng để tính toán được tổng thưởng. Điều kiện tiên quyết là mỗi tập <em>cuối cùng sẽ kết thúc</em> (dù sớm hay muộn) để ta thu được <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">G_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Với các bài toán continuing (chuỗi vô tận), người ta phải định nghĩa ngắt tập nhân tạo (ví dụ sau <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> bước) hoặc sử dụng chiết khấu và coi việc cắt chuỗi ở độ dài đủ lớn như “kết thúc”. Tuy nhiên, cách này chỉ cho ước lượng xấp xỉ và có thể bias nếu cắt quá ngắn. Do đó, MC <strong>không phù hợp lắm cho các nhiệm vụ không có hồi kết tự nhiên</strong> (so với TD có thể xử lý tốt bằng cách cập nhật dần).</p>
<p>Monte Carlo yêu cầu <strong>chính sách/thám hiểm phải bao phủ không gian trạng thái-hành động</strong>: tức về dài hạn, mọi trạng thái và hành động (cần đánh giá) đều phải có <em>xác suất ghé thăm dương</em>. Nếu không, một số phần của môi trường sẽ không bao giờ được học giá trị. Điều này đòi hỏi hoặc sử dụng <em>exploring starts</em> hoặc duy trì <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-greedy trong on-policy control, hoặc lựa chọn cẩn thận chính sách hành vi trong off-policy. Nói cách khác, <strong>điều kiện khám phá đầy đủ (exploration)</strong> là bắt buộc để đảm bảo tính đúng đắn của MC.</p>
<p>Về mặt hội tụ, MC dựa trên trung bình mẫu nên hiệu quả phụ thuộc nhiều vào <strong>độ biến động (variance)</strong> của phần thưởng. Nếu phần thưởng và quá trình chuyển trạng thái có nhiều ngẫu nhiên, returns thu được sẽ dao động mạnh, khiến việc hội tụ chậm. MC cho kết quả <em>không chệch</em> (unbiased) khi số mẫu tiến tới vô hạn, nhưng với số mẫu hữu hạn, phương sai cao có thể khiến ước lượng kém ổn định. Trường hợp extreme, như đã nêu với off-policy MC, <strong>phương sai có thể tiến tới vô hạn</strong> nếu dùng ordinary importance sampling không phù hợp (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=,and%20thus%20is%20strongly%20preferred">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>). Trong thực tế, người dùng MC thường phải chọn chiến lược giảm phương sai: ví dụ dùng weighted importance sampling, hoặc giảm dần <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> trong <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>-greedy, hoặc đơn giản là tăng số lần chạy mô phỏng.</p>
<p>Một hạn chế khác: Monte Carlo đòi hỏi <strong>nhiều thời gian và dữ liệu</strong> nếu môi trường lớn. Mặc dù mỗi tập có thể chỉ khám phá một phần không gian trạng thái, để đảm bảo đủ độ phủ, ta vẫn cần rất nhiều tập. Nếu một số sự kiện/trạng thái hiếm khi xảy ra, MC sẽ mất rất lâu mới thu thập đủ dữ liệu để đánh giá chúng chính xác. Trong khi đó, nếu có mô hình, ta có thể tính toán giá trị các trạng thái hiếm thông qua suy luận thay vì chờ chúng xảy ra.</p>
<p>Cuối cùng, <strong>tính thời gian thực</strong>: MC thường được xem là phương pháp “offline” hoặc <em>batch learning</em>, vì ta thường chạy nhiều tập mô phỏng, sau đó mới tổng hợp kết quả để cập nhật giá trị/policy. Trong môi trường thực tế liên tục, việc chờ đến cuối “tập” (ví dụ kết thúc một trò chơi) mới điều chỉnh có thể không kịp thời. Các phương pháp bootstrapping (như TD) cập nhật liên tục mỗi bước nên phù hợp hơn cho learning online, còn MC phù hợp khi ta có thể thu thập dữ liệu thành các phiên rời rạc.</p>
<p>Tóm lại, Monte Carlo thích hợp khi:</p>
<ul>
<li>Môi trường <strong>episodic rõ ràng</strong> (có trạng thái kết thúc).</li>
<li><strong>Không có mô hình</strong> hoặc mô phỏng môi trường dễ hơn là phân tích mô hình.</li>
<li>Muốn có ước lượng giá trị <strong>không chệch</strong> về dài hạn và chấp nhận việc cần nhiều mẫu.</li>
<li>Bài toán cho phép thu thập một tập lớn dữ liệu trải nghiệm (ví dụ mô phỏng trò chơi, vận hành thử nghiệm nhiều lần).</li>
</ul>
<p>Hạn chế của MC gồm:</p>
<ul>
<li>Không dùng tốt cho bài toán <strong>tiếp diễn vô tận</strong> (trừ khi thủ thuật chia tập).</li>
<li>Cần <strong>nhiều mẫu</strong> để hội tụ – phương sai cao.</li>
<li><strong>Chậm cập nhật</strong> (chỉ cuối tập), khó dùng trong môi trường yêu cầu phản ứng nhanh.</li>
<li>Đòi hỏi <strong>chiến lược thăm dò</strong> thích hợp; nếu không, kết quả học có thể sai lệch hoặc không đầy đủ.</li>
</ul>
<p>Dù có hạn chế, Monte Carlo vẫn là công cụ mạnh trong RL, đặc biệt ở giai đoạn khởi đầu hoặc trong nghiên cứu lý thuyết, vì sự đơn giản và rõ ràng trong ý tưởng: “<strong>Hãy chơi nhiều lần và học từ những gì đã xảy ra</strong>”.</p>
<h2 id="ví-dụ-minh-họa-chi-tiết-đánh-giá-chiến-lược-trong-trò-blackjack-bằng-monte-carlo">Ví dụ minh họa chi tiết: Đánh giá chiến lược trong trò Blackjack bằng Monte Carlo</h2>
<p>Để làm rõ hơn cách phương pháp Monte Carlo hoạt động, chúng ta xét <strong>ví dụ trò chơi Blackjack</strong> kinh điển trong tài liệu của Sutton &amp; Barto (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=Example%3A%20Blackjack%20%E2%80%A2%20Goal%3A%20Achieve,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>). Blackjack (Xì dách) là trò chơi mà mục tiêu của người chơi là rút được tổng điểm các lá bài <strong>gần 21 nhất nhưng không vượt quá 21</strong>, đồng thời cao hơn điểm của nhà cái. Mỗi ván Blackjack là một <em>tập tương tác</em> tự nhiên: nó bắt đầu với việc chia bài và kết thúc khi người chơi dừng hoặc bị quá 21, sau đó so sánh điểm với nhà cái để xác định thắng/thua.</p>
<p><strong>Mô tả môi trường Blackjack đơn giản</strong> (<em>theo mô hình trong sách</em> (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=Example%3A%20Blackjack%20%E2%80%A2%20Goal%3A%20Achieve,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>)):</p>
<ul>
<li><strong>Trạng thái:</strong> Được biểu diễn bởi bộ ba <code>(tổng điểm của người chơi, lá bài ngửa của nhà cái, có usable ace không)</code>. Ở đây <em>usable ace</em> nghĩa là người chơi có quân Át được tính là 11 điểm mà không bị quá 21. Tổng điểm của người chơi được giới hạn từ 12 đến 21 (vì dưới 12 điểm chắc chắn người chơi sẽ rút thêm), lá ngửa của dealer từ 1 (Át) đến 10 (10, J, Q, K đều tính 10 điểm). Như vậy không gian trạng thái có <strong>200 trạng thái khả dĩ</strong> (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=%E2%80%A2%20State%20space%3A%20,works%2011%2F10%2F2010%20Reinforcement%20Learning%2013">Structure and Synthesis of Robot Motion  Introduction </a>).</li>
<li><strong>Hành động:</strong> Gồm hai hành động chính: <strong>“Hit” (rút thêm bài)</strong> hoặc <strong>“Stick” (dừng, không rút thêm)</strong> (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=%E2%80%A2%20Reward%3A%20%2B1%20for%20win%2C,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>).</li>
<li><strong>Phần thưởng:</strong> +1 nếu người chơi thắng (điểm cao hơn dealer hoặc dealer quá 21), 0 nếu hòa, –1 nếu thua (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=%E2%80%93%20Dealer%E2%80%99s%20showing%20card%20,receive%20another%20card">Structure and Synthesis of Robot Motion  Introduction </a>). Phần thưởng chỉ nhận được khi kết thúc ván.</li>
<li><strong>Chính sách của người chơi (cần đánh giá):</strong> Ở ví dụ này, ta xét một chiến lược đơn giản: <strong>rút bài cho đến khi đạt được 20 điểm hoặc 21 thì dừng</strong>, cụ thể: <em>nếu tổng điểm hiện tại của người chơi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\ge 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span> thì Stick, ngược lại thì Hit</em> (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=%E2%80%A2%20Reward%3A%20%2B1%20for%20win%2C,works%2011%2F10%2F2010%20Reinforcement%20Learning%2013">Structure and Synthesis of Robot Motion  Introduction </a>). Đây là một chính sách cố định, không tối ưu nhưng hợp lý để minh họa (một dạng “chiến thuật cơ bản” giản lược).</li>
</ul>
<p>Nhiệm vụ của ta: <strong>ước lượng giá trị của mỗi trạng thái</strong> dưới chính sách cố định trên bằng phương pháp Monte Carlo. Do không có mô hình xác suất chính xác cho Blackjack (bài trộn ngẫu nhiên), ta sẽ dùng mô phỏng Monte Carlo: cho người chơi và nhà cái chơi nhiều ván theo luật và theo chính sách đã cho của người chơi, rồi thống kê kết quả.</p>
<p><strong>Áp dụng Monte Carlo prediction:</strong></p>
<p>Ta thực hiện giả lập hàng trăm nghìn ván Blackjack. Trong mỗi ván, ta theo dõi chuỗi trạng thái và hành động của người chơi. Với chính sách trên, người chơi sẽ rút bài đến khi đạt 20 hoặc 21 điểm rồi dừng, sau đó phần thưởng được xác định (thắng/hòa/thua). Sử dụng <em>first-visit MC</em>, ta cập nhật giá trị cho <strong>trạng thái đầu tiên</strong> của mỗi ván (hoặc ta cũng có thể cập nhật cho mọi trạng thái trong ván – tuy nhiên do chính sách ở đây cố định và phần thưởng chỉ có khi kết thúc, giá trị các trạng thái trung gian có thể suy luận tương tự trạng thái đầu do Markov, nhưng chúng ta cứ làm tổng quát). Cụ thể: nếu trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mtext>ổ</mtext><mi>n</mi><mi>g</mi><mo separator="true">,</mo><mi>b</mi><mover accent="true"><mi>a</mi><mo>ˋ</mo></mover><mi>i</mi><mi>d</mi><mi>e</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo separator="true">,</mo><mi>a</mi><mi>c</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s = (tổng, bài dealer, ace)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">ổ</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˋ</span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">ce</span><span class="mclose">)</span></span></span></span> xuất hiện lần đầu trong ván và kết quả ván là thắng (+1), ta cộng +1 vào danh sách returns của <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>. Nếu thua, cộng -1, hòa thì 0. Sau rất nhiều ván, giá trị ước lượng <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> cho trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> sẽ là trung bình các kết quả thu được từ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>.</p>
<p>Monte Carlo không những cho ta ước lượng giá trị của từng trạng thái mà còn có thể cho cái nhìn trực quan về chiến lược. <strong>Hình dưới đây</strong> minh họa <em>hàm giá trị trạng thái <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mi>π</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V^{\pi}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> ước lượng được cho chính sách trên trong Blackjack</em>, phân biệt hai trường hợp: khi người chơi <strong>có</strong> một Át hữu dụng (trái) và <strong>không có</strong> Át hữu dụng (phải). Biểu đồ bên trái của mỗi cặp là giá trị ước lượng sau 10.000 ván, bên phải là sau 500.000 ván (gần hội tụ) (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=The%20left%20hand%20graphs%20are,will%20look%20like%20before%20convergence">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>):</p>
<p>(<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>) <em>Hàm giá trị ước lượng của chính sách &quot;rút đến 20 rồi dừng&quot; trong Blackjack, phân tách theo trường hợp người chơi có <strong>usable ace</strong> (trên) hoặc không có (dưới). Mỗi đồ thị bên trái ứng với sau 10.000 ván (chưa hội tụ), bên phải ứng với sau 500.000 ván (gần hội tụ). Trục hoành là lá bài ngửa của dealer (A=Át, 2-10), trục tung là tổng điểm của người chơi (12-21). Giá trị trạng thái được biểu diễn theo thang màu độ cao, từ -1 (thua chắc) đến +1 (thắng chắc).</em> (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=The%20left%20hand%20graphs%20are,will%20look%20like%20before%20convergence">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>) (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=,build%20the%20chart%20is%20lower">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>)</p>
<p>Nhìn vào kết quả, ta thấy sau khoảng <strong>500.000 ván mô phỏng</strong>, hàm giá trị đã khá ổn định (bề mặt giá trị trơn tru hơn), phản ánh chính xác chất lượng các trạng thái dưới chiến lược đã cho. Những trạng thái “ tốt ” – ví dụ tổng điểm cao (gần 21) – có giá trị dương (cơ hội thắng cao), trong khi những trạng thái “xấu” – điểm thấp, đặc biệt khi dealer có lá lớn – có giá trị âm (dễ thua). Sự khác biệt giữa trường hợp <strong>có Át hữu dụng</strong> và <strong>không có Át</strong> cũng được Monte Carlo thể hiện: Với một Át mềm (usable ace), người chơi có lợi thế linh hoạt (Át có thể tính 11 hoặc 1), do đó ngay cả với tổng điểm chưa cao, xác suất thắng có thể nhỉnh hơn so với khi không có Át. Chẳng hạn, ở tổng điểm ~15 và dealer đang có 4, nếu người chơi có Át mềm thì giá trị kỳ vọng có thể dương (có cơ hội thắng) do khả năng điều chỉnh Át, trong khi không có Át thì tình huống đó khá bất lợi. Điều này giải thích tại sao bề mặt giá trị “có Át” nhìn chung cao hơn một chút và cũng <strong>hội tụ chậm hơn</strong> – các trạng thái với Át hiếm gặp hơn (xác suất ~15% mỗi ván) và kết quả biến động hơn do sự linh hoạt của Át (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=,build%20the%20chart%20is%20lower">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>), nên cần nhiều ván hơn để ước lượng chính xác.</p>
<p>Monte Carlo đã thành công trong việc <strong>dự đoán giá trị</strong> cho từng trạng thái Blackjack theo chính sách đã cho một cách gần đúng. Từ kết quả này, ta có thể <strong>cải thiện chính sách</strong>: ví dụ, nếu ở một số trạng thái cụ thể giá trị của hành động “Hit” cao hơn “Stick” (mà chính sách ban đầu chưa chọn tối ưu), ta có thể điều chỉnh chiến lược. Thật vậy, Sutton &amp; Barto tiếp tục dùng phương pháp <strong>Monte Carlo control</strong> (với exploring starts) trên trò Blackjack và thu được <strong>chính sách tối ưu</strong> gần giống chiến lược chơi tối ưu mà các cao thủ blackjack khuyến nghị. Điều này minh họa sức mạnh của MC: chỉ bằng cách chơi thử và ghi nhận kết quả, phương pháp đã tự động tìm ra chiến lược tốt.</p>
<p><strong>Kết luận ví dụ:</strong> Trong trò Blackjack, Monte Carlo cung cấp một cách tiếp cận tự nhiên: chơi nhiều ván và <strong>mô phỏng trải nghiệm</strong>. Thông qua việc ghi nhận thắng/thua và trung bình cộng, ta đánh giá được chất lượng của các trạng thái. So sánh với cách phân tích toán xác suất của trò chơi (vốn rất phức tạp do nhiều tình huống bài), phương pháp MC đơn giản hơn nhiều – ta không cần giải công thức nào, chỉ cần đủ dữ liệu. Ví dụ này cho thấy Monte Carlo rất hữu dụng trong những tình huống mà mô phỏng dễ dàng nhưng phân tích lý thuyết thì khó. Chính nhờ khả năng “thực nghiệm” này, phương pháp Monte Carlo trở thành một trong những công cụ quan trọng trong học tăng cường, đặt nền móng cho các thuật toán hiện đại hơn trong lĩnh vực trí tuệ nhân tạo.</p>
<p><strong>Nguồn tài liệu tham khảo:</strong> Sutton &amp; Barto (2018) – <em>Reinforcement Learning: An Introduction</em> (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=First%20learning%20method%20for%20estimating,we%20learn%20only%20by%20experience">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=An%20obvious%20way%20to%20estimate,converge%20to%20the%20expected%20value">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>) (<a href="https://lcalem.github.io/blog/2018/10/22/sutton-chap05-montecarlo#:~:text=We%20can%20apply%20backup%20diagrams,instead%20of%20all%20possible%20transitions">Sutton &amp; Barto summary chap 05 - Monte Carlo methods | lcalem</a>); Shiyu Zhao (2025) – <em>Mathematical Foundations of Reinforcement Learning</em> (<a href="https://page-one.springer.com/pdf/preview/10.1007/978-981-97-3944-8_5#:~:text=based%20on%20the%20system%20model,If%20we%20do%20not%20have"></a>); cùng các ghi chú, bài giảng RL kinh điển (<a href="https://users.ece.cmu.edu/~yuejiec/ece18813B_notes/lecture8-model-free-MC-TD.pdf#:~:text=Dynamic%20programming%20versus%20Monte%20Carlo,11">Foundations of Reinforcement Learning  Model-free RL: Monte Carlo and temporal difference (TD) learning</a>) (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=Example%3A%20Blackjack%20%E2%80%A2%20Goal%3A%20Achieve,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>). Các ví dụ và phân tích cụ thể về Blackjack được trích từ Sutton &amp; Barto (Ch.5) (<a href="https://www.inf.ed.ac.uk/teaching/courses/rl/slides10/5_MC1.pdf#:~:text=Example%3A%20Blackjack%20%E2%80%A2%20Goal%3A%20Achieve,20%20or%2021%2C%20else%20hit">Structure and Synthesis of Robot Motion  Introduction </a>) và luận giải bởi cộng đồng AI (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=The%20left%20hand%20graphs%20are,will%20look%20like%20before%20convergence">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>) (<a href="https://ai.stackexchange.com/questions/17808/what-does-the-figure-blackjack-value-function-from-sutton-represent#:~:text=,build%20the%20chart%20is%20lower">reinforcement learning - What does the figure &quot;Blackjack Value Function...&quot; from Sutton represent? - Artificial Intelligence Stack Exchange</a>).</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>